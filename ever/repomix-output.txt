This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: lib/domain/usecases
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
domain/
  core/
    circuit_breaker.dart
    events.dart
    retry_config.dart
    retry_events.dart
    service_events.dart
    user_events.dart
  datasources/
    base_ds.dart
    note_ds.dart
    task_ds.dart
    user_ds.dart
  entities/
    note.dart
    task.dart
    user.dart
  repositories/
    base_repository.dart
    user_repository.dart
  usecases/
    user/
      get_current_user_usecase.dart
      login_usecase.dart
      refresh_token_usecase.dart
      register_usecase.dart
      reset_password_usecase.dart
      sign_out_usecase.dart
      update_profile_usecase.dart
    base_usecase.dart
implementations/
  config/
    api_config.dart
    error_messages.dart
  datasources/
    user_ds_impl.dart
  models/
    auth_credentials.dart
    auth_credentials.g.dart
    user_model.dart
  repositories/
    user_repository_impl.dart

================================================================
Files
================================================================

================
File: domain/core/circuit_breaker.dart
================
import 'dart:async';
import 'package:meta/meta.dart';

/// Circuit breaker states.
enum CircuitState { closed, open, halfOpen }

/// Configuration for circuit breaker pattern.
class CircuitBreakerConfig {
  /// Number of failures before opening the circuit.
  final int failureThreshold;

  /// How long to wait before attempting recovery.
  final Duration resetTimeout;

  /// Maximum number of trial calls allowed in half‑open state.
  final int halfOpenMaxAttempts;

  /// Default configuration with reasonable values.
  static const CircuitBreakerConfig defaultConfig = CircuitBreakerConfig(
    failureThreshold: 5,
    resetTimeout: Duration(seconds: 30),
    halfOpenMaxAttempts: 3,
  );

  const CircuitBreakerConfig({
    required this.failureThreshold,
    required this.resetTimeout,
    required this.halfOpenMaxAttempts,
  });
}

/// Implementation of the circuit breaker pattern.
class CircuitBreaker {
  final CircuitBreakerConfig _config;
  final _eventController = StreamController<CircuitBreakerEvent>.broadcast();

  CircuitState _state = CircuitState.closed;
  int _failures = 0;
  int _halfOpenAttempts = 0;
  DateTime? _lastFailure;
  Timer? _resetTimer;

  CircuitBreaker([CircuitBreakerConfig? config])
      : _config = config ?? CircuitBreakerConfig.defaultConfig;

  /// Current state of the circuit.
  CircuitState get state => _state;

  /// Stream of circuit breaker events.
  Stream<CircuitBreakerEvent> get events => _eventController.stream;

  /// Check if enough time has passed to attempt reset
  @visibleForTesting
  bool get shouldAttemptReset {
    if (_lastFailure == null) return false;
    final elapsed = DateTime.now().difference(_lastFailure!);
    return elapsed >= _config.resetTimeout;
  }

  /// Execute an operation through the circuit breaker.
  Future<T> execute<T>(Future<T> Function() operation) async {
    if (_state == CircuitState.open) {
      if (shouldAttemptReset) {
        _transitionToHalfOpen();
      } else {
        _eventController.add(CircuitBreakerEvent.operationRejected());
        throw CircuitBreakerException('Circuit is open');
      }
    }

    if (_state == CircuitState.halfOpen) {
      if (_halfOpenAttempts >= _config.halfOpenMaxAttempts) {
        _eventController.add(CircuitBreakerEvent.operationRejected());
        throw CircuitBreakerException('Maximum half-open attempts reached');
      }
      _halfOpenAttempts++;
    }

    try {
      final result = await operation();
      if (_state == CircuitState.halfOpen) {
        // Only transition to closed if we've used all allowed trial attempts
        if (_halfOpenAttempts >= _config.halfOpenMaxAttempts) {
          _transitionToClosed();
        }
      } else if (_state == CircuitState.closed) {
        _failures = 0;
      }
      return result;
    } catch (error) {
      if (_state == CircuitState.halfOpen) {
        // Any failure in half-open immediately transitions back to open
        _transitionToOpen();
      } else if (_state == CircuitState.closed) {
        _failures++;
        if (_failures >= _config.failureThreshold) {
          _transitionToOpen();
        }
      }
      rethrow;
    }
  }

  /// Transition to closed state.
  void _transitionToClosed() {
    _state = CircuitState.closed;
    _failures = 0;
    _halfOpenAttempts = 0;
    _lastFailure = null;
    _resetTimer?.cancel();
    _eventController.add(CircuitBreakerEvent.transitionToClosed());
  }

  /// Transition to open state.
  void _transitionToOpen() {
    _state = CircuitState.open;
    _lastFailure = DateTime.now();
    _halfOpenAttempts = 0;
    _resetTimer?.cancel();
    // Schedule automatic transition to half-open after reset timeout
    _resetTimer = Timer(_config.resetTimeout, _transitionToHalfOpen);
    _eventController.add(CircuitBreakerEvent.transitionToOpen());
  }

  /// Transition to half‑open state.
  void _transitionToHalfOpen() {
    _state = CircuitState.halfOpen;
    _halfOpenAttempts = 0;
    _eventController.add(CircuitBreakerEvent.transitionToHalfOpen());
  }

  /// Reset the circuit breaker to its initial state.
  void reset() {
    _state = CircuitState.closed;
    _failures = 0;
    _halfOpenAttempts = 0;
    _lastFailure = null;
    _resetTimer?.cancel();
    _eventController.add(CircuitBreakerEvent.transitionToClosed());
  }

  /// Dispose of resources.
  void dispose() {
    _resetTimer?.cancel();
    _eventController.close();
  }

  // The following method is made public for testing purposes only.
  @visibleForTesting
  void forceTransitionToHalfOpen() {
    _transitionToHalfOpen();
  }
}

/// Events emitted by the circuit breaker.
class CircuitBreakerEvent {
  final String type;
  final String? message;
  final DateTime timestamp;

  CircuitBreakerEvent._(this.type, [this.message]) : timestamp = DateTime.now();

  factory CircuitBreakerEvent.transitionToOpen() =>
      CircuitBreakerEvent._('transition_to_open');

  factory CircuitBreakerEvent.transitionToHalfOpen() =>
      CircuitBreakerEvent._('transition_to_half_open');

  factory CircuitBreakerEvent.transitionToClosed() =>
      CircuitBreakerEvent._('transition_to_closed');

  factory CircuitBreakerEvent.operationRejected() =>
      CircuitBreakerEvent._('operation_rejected', 'Operation rejected due to circuit breaker state');
}

/// Exception thrown when circuit breaker prevents an operation.
class CircuitBreakerException implements Exception {
  final String message;
  CircuitBreakerException(this.message);

  @override
  String toString() => 'CircuitBreakerException: $message';
}

================
File: domain/core/events.dart
================
/// Base class for all domain events
abstract class DomainEvent {
  const DomainEvent();
}

/// Event emitted when an operation starts
class OperationInProgress extends DomainEvent {
  final String operation;

  const OperationInProgress(this.operation);
}

/// Event emitted when an operation succeeds
class OperationSuccess<T> extends DomainEvent {
  final String operation;
  final T? data;

  const OperationSuccess(this.operation, [this.data]);
}

/// Event emitted when an operation fails
class OperationFailure extends DomainEvent {
  final String operation;
  final String error;

  const OperationFailure(this.operation, this.error);
}

================
File: domain/core/retry_config.dart
================
import 'dart:async';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'dart:math';

/// Configuration for retry mechanism with exponential backoff
class RetryConfig {
  /// Maximum number of retry attempts
  final int maxAttempts;

  /// Initial delay before first retry
  final Duration initialDelay;

  /// Maximum delay between retries
  final Duration maxDelay;

  /// Multiplier for each subsequent retry
  final double backoffFactor;

  /// Default configuration with reasonable values
  static const RetryConfig defaultConfig = RetryConfig(
    maxAttempts: 3,
    initialDelay: Duration(seconds: 1),
    maxDelay: Duration(seconds: 10),
    backoffFactor: 2.0,
  );

  const RetryConfig({
    required this.maxAttempts,
    required this.initialDelay,
    required this.maxDelay,
    required this.backoffFactor,
  });

  /// Calculate delay for a specific attempt number
  Duration getDelayForAttempt(int attempt) {
    if (attempt <= 0) return Duration.zero;
    
    // Calculate exponential delay: initialDelay * (backoffFactor ^ (attempt - 1))
    final multiplier = pow(backoffFactor, attempt - 1).toDouble();
    final exponentialDelay = initialDelay * multiplier;
    return exponentialDelay > maxDelay ? maxDelay : exponentialDelay;
  }

  /// Check if an error should trigger a retry
  bool shouldRetry(Object error) {
    if (error is TimeoutException) return true;
    if (error is http.ClientException) return true;
    if (error is SocketException) return true;
    final errorString = error.toString().toLowerCase();
    return errorString.contains('500') ||
           errorString.contains('502') ||
           errorString.contains('503') ||
           errorString.contains('504');
  }
}

/// Extension to add retry capability to Future operations
extension RetryableOperation<T> on Future<T> Function() {
  /// Execute the operation with retry logic
  Future<T> withRetry(RetryConfig config) async {
    int attempts = 0;
    
    while (true) {
      try {
        attempts++;
        return await this();
      } catch (error) {
        if (!config.shouldRetry(error) || attempts >= config.maxAttempts) {
          rethrow;
        }
        
        final delay = config.getDelayForAttempt(attempts);
        await Future.delayed(delay);
      }
    }
  }
}

================
File: domain/core/retry_events.dart
================
import 'events.dart';

/// Event emitted when a retry attempt is about to start
class RetryAttempt extends DomainEvent {
  /// The operation being retried
  final String operation;
  
  /// The attempt number (1-based)
  final int attempt;
  
  /// The delay before this attempt
  final Duration delay;
  
  /// The error that triggered this retry
  final Object error;

  const RetryAttempt(
    this.operation,
    this.attempt,
    this.delay,
    this.error,
  );
}

/// Event emitted when a retry succeeds
class RetrySuccess extends DomainEvent {
  /// The operation that succeeded
  final String operation;
  
  /// The number of attempts it took
  final int attempts;

  const RetrySuccess(this.operation, this.attempts);
}

/// Event emitted when all retries are exhausted
class RetryExhausted extends DomainEvent {
  /// The operation that failed
  final String operation;
  
  /// The final error
  final Object error;
  
  /// The number of attempts made
  final int attempts;

  const RetryExhausted(this.operation, this.error, this.attempts);
}

================
File: domain/core/service_events.dart
================
import 'events.dart';

/// Event emitted when service is degraded
class ServiceDegraded extends DomainEvent {
  final DateTime timestamp;
  
  const ServiceDegraded(this.timestamp);
}

/// Event emitted when service is restored
class ServiceRestored extends DomainEvent {
  final DateTime timestamp;
  
  const ServiceRestored(this.timestamp);
}

/// Event emitted when service is recovered
class ServiceRecovered extends DomainEvent {
  final DateTime timestamp;
  
  const ServiceRecovered(this.timestamp);
}

/// Event emitted when operation is rejected due to service state
class OperationRejected extends DomainEvent {
  final String reason;
  
  const OperationRejected(this.reason);
}

================
File: domain/core/user_events.dart
================
import 'events.dart';

/// Event when user successfully registers
class UserRegistered extends DomainEvent {
  final dynamic user;
  final String userSecret;

  const UserRegistered(this.user, this.userSecret);
}

/// Event when user registration fails
class RegistrationFailed extends DomainEvent {
  final String message;
  RegistrationFailed(this.message);
}

/// Event when token is obtained
class TokenObtained extends DomainEvent {
  final String token;
  final DateTime expiresAt;

  const TokenObtained(this.token, this.expiresAt);
}

/// Event when token acquisition fails
class TokenAcquisitionFailed extends DomainEvent {
  final String message;
  TokenAcquisitionFailed(this.message);
}

/// Event when token is about to expire
class TokenExpiring extends DomainEvent {
  final Duration timeLeft;
  TokenExpiring(this.timeLeft);
}

/// Event when token has expired
class TokenExpired extends DomainEvent {}

/// Event when token refresh succeeds
class TokenRefreshed extends DomainEvent {
  final String accessToken;
  final DateTime expiresAt;
  TokenRefreshed(this.accessToken, this.expiresAt);
}

/// Event when token refresh fails
class TokenRefreshFailed extends DomainEvent {
  final String error;

  const TokenRefreshFailed(this.error);
}

/// Event when current user info is retrieved
class CurrentUserRetrieved extends DomainEvent {
  final dynamic user;

  const CurrentUserRetrieved(this.user);
}

/// Event when user logs out
class UserLoggedOut extends DomainEvent {
  const UserLoggedOut();
}

================
File: domain/datasources/base_ds.dart
================
import 'dart:async';
import '../core/events.dart';

/// Base interface for all data sources
/// All operations are reactive and return Streams
abstract class BaseDataSource<T> {
  /// Stream of domain events from this data source
  Stream<DomainEvent> get events;

  /// Create a new entity
  /// Returns a Stream that emits the created entity
  /// Throws UnsupportedError if operation is not supported
  Stream<T> create(T entity);

  /// Read an entity by ID
  /// Returns a Stream that emits the retrieved entity
  /// Throws UnsupportedError if operation is not supported
  Stream<T> read(String id);

  /// Update an existing entity
  /// Returns a Stream that emits the updated entity
  /// Throws UnsupportedError if operation is not supported
  Stream<T> update(T entity);

  /// Delete an entity by ID
  /// Returns a Stream that completes when deletion is done
  /// Throws UnsupportedError if operation is not supported
  Stream<void> delete(String id);

  /// List all entities with optional filtering
  /// Returns a Stream that emits the list of entities
  /// Throws UnsupportedError if operation is not supported
  Stream<List<T>> list({Map<String, dynamic>? filters});

  /// Initialize the data source
  /// This should be called before using the data source
  /// Returns a Future that completes when initialization is done
  Future<void> initialize();

  /// Check if an operation is supported by this data source
  /// [operation]: The operation to check ('create', 'read', 'update', 'delete', 'list')
  bool isOperationSupported(String operation);

  /// Dispose of any resources
  /// This should be called when the data source is no longer needed
  void dispose();
}

================
File: domain/datasources/note_ds.dart
================
import '../entities/note.dart';
import 'base_ds.dart';

/// Data source interface for Note operations
abstract class NoteDataSource extends BaseDataSource<Note> {
  /// Search notes by content
  Future<List<Note>> search(String query);
  
  /// Process note content and update enrichment data
  Future<Note> process(String noteId);
  
  /// Add attachment to note
  Future<Note> addAttachment(String noteId, Attachment attachment);
}

================
File: domain/datasources/task_ds.dart
================
import '../entities/task.dart';
import 'base_ds.dart';

/// Data source interface for Task operations
abstract class TaskDataSource extends BaseDataSource<Task> {
  /// Get tasks by status
  Future<List<Task>> getByStatus(TaskStatus status);
  
  /// Get tasks by priority
  Future<List<Task>> getByPriority(TaskPriority priority);
  
  /// Get subtasks for a given task
  Future<List<Task>> getSubtasks(String taskId);
  
  /// Update task status
  Future<Task> updateStatus(String taskId, TaskStatus status);
}

================
File: domain/datasources/user_ds.dart
================
import '../entities/user.dart';
import 'base_ds.dart';

/// Data source interface for User operations
abstract class UserDataSource extends BaseDataSource<User> {
  /// Register a new user
  /// Returns a Stream that emits the registered User
  /// Emits error if registration fails
  Stream<User> register(String username);
  
  /// Get currently authenticated user info
  /// Returns a Stream that emits the current User
  /// Emits error if user is not authenticated or not found
  Stream<User> getCurrentUser();
  
  /// Obtain access token using user secret
  /// Returns a Stream that emits the access token
  /// This is idempotent - multiple concurrent calls will return the same result
  /// Emits error if token acquisition fails
  Stream<String> obtainToken(String userSecret);

  /// Initialize the data source
  /// Loads cached credentials and sets up token refresh handling
  @override
  Future<void> initialize();

  /// Sign out user and clear cached credentials
  /// Returns a Stream that completes when sign out is done
  /// Emits error if sign out fails
  Stream<void> signOut();

  /// Execute an API call with automatic token refresh on 401/403
  /// T is the expected return type
  /// apiCall: The actual API call to make
  /// onRefreshSuccess: Optional callback when token is refreshed
  /// Returns the result of the API call
  /// Emits error if the call fails and token refresh doesn't help
  Future<T> executeWithRefresh<T>(
    Future<T> Function() apiCall,
    Future<void> Function()? onRefreshSuccess,
  );

  /// Check if a token refresh is in progress
  bool get isRefreshing;

  /// Get the cached user secret if any
  Future<String?> get cachedUserSecret;

  /// Get the cached access token if any
  Future<String?> get cachedAccessToken;

  /// Get the token expiration time if any
  Future<DateTime?> get tokenExpiresAt;

  @override
  bool isOperationSupported(String operation) => false;
}

================
File: domain/entities/note.dart
================
/// Represents a note in the system
class Note {
  final String id;
  final String content;
  final Attachment? attachment;
  final ProcessingStatus processingStatus;
  final Map<String, dynamic> enrichmentData;

  const Note({
    required this.id,
    required this.content,
    this.attachment,
    this.processingStatus = ProcessingStatus.notProcessed,
    this.enrichmentData = const {},
  });
}

/// Represents an attachment to a note
class Attachment {
  final String type;
  final String url;

  const Attachment({
    required this.type,
    required this.url,
  });
}

/// Status of note processing
enum ProcessingStatus {
  notProcessed,
  pending,
  completed,
  failed,
}

================
File: domain/entities/task.dart
================
/// Represents a task in the system
class Task {
  final String id;
  final String content;
  final TaskStatus status;
  final TaskPriority priority;
  final DateTime? dueDate;
  final List<String> tags;
  final String? parentId;
  final String? topicId;

  const Task({
    required this.id,
    required this.content,
    this.status = TaskStatus.todo,
    this.priority = TaskPriority.medium,
    this.dueDate,
    this.tags = const [],
    this.parentId,
    this.topicId,
  });
}

/// Status of a task
enum TaskStatus {
  todo,
  inProgress,
  done,
}

/// Priority of a task
enum TaskPriority {
  low,
  medium,
  high,
}

================
File: domain/entities/user.dart
================
/// Domain entity representing a user
class User {
  final String id;
  final String username;
  final String? userSecret;
  final DateTime createdAt;
  final DateTime? updatedAt;

  const User({
    required this.id,
    required this.username,
    this.userSecret,
    required this.createdAt,
    this.updatedAt,
  });

  /// Creates a copy of this User with the given fields replaced with new values
  User copyWith({
    String? id,
    String? username,
    String? userSecret,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return User(
      id: id ?? this.id,
      username: username ?? this.username,
      userSecret: userSecret ?? this.userSecret,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          username == other.username &&
          userSecret == other.userSecret &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;

  @override
  int get hashCode =>
      id.hashCode ^
      username.hashCode ^
      userSecret.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;
}

================
File: domain/repositories/base_repository.dart
================
import 'dart:async';
import '../core/events.dart';

/// Base interface for all repositories
/// All operations return Streams to maintain reactive pattern consistency
abstract class BaseRepository<T> {
  /// Stream of domain events from this repository
  Stream<DomainEvent> get events;

  /// Create a new entity
  /// Returns a Stream of the created entity
  Stream<T> create(T entity);

  /// Read an entity by ID
  /// Returns a Stream of the retrieved entity
  Stream<T> read(String id);

  /// Update an existing entity
  /// Returns a Stream of the updated entity
  Stream<T> update(T entity);

  /// Delete an entity by ID
  /// Returns a Stream that completes when deletion is done
  Stream<void> delete(String id);

  /// List all entities with optional filtering
  /// Returns a Stream of entity lists
  Stream<List<T>> list({Map<String, dynamic>? filters});

  /// Dispose of any resources
  void dispose();
}

================
File: domain/repositories/user_repository.dart
================
import '../entities/user.dart';
import 'base_repository.dart';

/// Repository interface for User operations
abstract class UserRepository extends BaseRepository<User> {
  /// Register a new user with username
  /// Returns a Stream of the registered User
  Stream<User> register(String username);
  
  /// Obtain access token using user secret
  /// Returns a Stream that emits the token when obtained
  Stream<String> obtainToken(String userSecret);

  /// Refresh the access token using user secret
  /// Returns a Stream that emits the new token when refreshed
  Stream<String> refreshToken();
  
  /// Get currently authenticated user info
  /// Returns a Stream of the current User
  Stream<User> getCurrentUser();
  
  /// Sign out current user (clear token)
  /// Returns a Stream that completes when sign out is done
  Stream<void> signOut();
  
  /// Check if user has a valid token
  bool get isAuthenticated;
  
  /// Get current access token if any
  String? get currentToken;
  
  /// Get current user secret if any
  String? get currentUserSecret;

  /// Get token expiration time if any
  DateTime? get tokenExpiresAt;
}

================
File: domain/usecases/user/get_current_user_usecase.dart
================
import 'dart:async';

import '../../core/events.dart';
import '../../repositories/user_repository.dart';
import '../base_usecase.dart';

/// Use case for retrieving the current authenticated user
/// 
/// Events:
/// - [UserRetrieved]: When user is successfully retrieved
/// - [UserNotFound]: When no authenticated user exists
/// - [OperationFailure]: When retrieval fails for other reasons
/// - [OperationInProgress]: When retrieval is in progress
class GetCurrentUserUseCase extends NoParamsUseCase {
  final UserRepository _repository;
  final _eventController = StreamController<DomainEvent>.broadcast();
  
  /// Whether a retrieval operation is in progress
  bool _isRetrieving = false;

  GetCurrentUserUseCase(this._repository) {
    // Listen to repository events and transform them if needed
    _repository.events.listen((event) {
      if (event is UserRetrieved) {
        _isRetrieving = false;
        _eventController.add(event);
      } else if (event is OperationFailure) {
        _isRetrieving = false;
        // Transform generic failure to user-specific failure if needed
        if (event.error.contains('not found') || 
            event.error.contains('no user') ||
            event.error.contains('unauthorized')) {
          _eventController.add(UserNotFound());
        } else {
          _eventController.add(event);
        }
      } else if (event is OperationInProgress) {
        _eventController.add(event);
      }
    });
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  void execute([void params]) {
    if (_isRetrieving) return; // Prevent concurrent retrievals
    
    _isRetrieving = true;
    _repository.getCurrentUser();
  }

  @override
  void dispose() {
    _eventController.close();
  }
}

================
File: domain/usecases/user/login_usecase.dart
================
import 'dart:async';

import '../../core/events.dart';
import '../../core/user_events.dart';
import '../../repositories/user_repository.dart';
import '../base_usecase.dart';

/// Parameters for obtaining an access token
class ObtainTokenParams {
  /// User secret obtained during registration
  /// Used to obtain new access tokens
  final String userSecret;

  const ObtainTokenParams({
    required this.userSecret,
  });

  /// Validate token parameters
  String? validate() {
    final trimmed = userSecret.trim();
    if (trimmed.isEmpty) {
      return 'User secret cannot be empty';
    }
    // Add more validation if needed based on user secret format
    return null;
  }
}

/// Use case for obtaining an access token
/// 
/// Flow:
/// 1. Validates the user secret
/// 2. Calls repository to obtain token
/// 3. Emits appropriate events:
///    - [OperationInProgress]: When token acquisition starts
///    - [TokenObtained]: When token is obtained successfully
///    - [TokenAcquisitionFailed]: When validation or token acquisition fails
///    - [TokenExpiring]: When token is about to expire (via RefreshTokenUseCase)
///    - [TokenExpired]: When token has expired (via RefreshTokenUseCase)
class ObtainTokenUseCase extends BaseUseCase<ObtainTokenParams> {
  final UserRepository _repository;
  final _eventController = StreamController<DomainEvent>.broadcast();

  ObtainTokenUseCase(this._repository) {
    // Listen to repository events and transform them if needed
    _repository.events.listen((event) {
      if (event is TokenObtained) {
        // Forward token events as is
        _eventController.add(event);
      } else if (event is OperationFailure) {
        // Transform generic failure to token-specific failure
        _eventController.add(TokenAcquisitionFailed(event.error));
      } else if (event is OperationInProgress) {
        _eventController.add(event);
      }
    });
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  void execute(ObtainTokenParams params) {
    // Validate input parameters
    final validationError = params.validate();
    if (validationError != null) {
      _eventController.add(TokenAcquisitionFailed(validationError));
      return;
    }

    // Proceed with token acquisition
    _repository.obtainToken(params.userSecret.trim());
  }

  @override
  void dispose() {
    _eventController.close();
  }
}

================
File: domain/usecases/user/refresh_token_usecase.dart
================
import 'dart:async';

import '../../core/events.dart';
import '../../repositories/user_repository.dart';
import '../base_usecase.dart';

/// Use case for managing token refresh and expiration
/// 
/// Responsibilities:
/// 1. Automatic token refresh before expiration
/// 2. Token expiration monitoring
/// 3. Warning emission before token expires
/// 
/// Events:
/// - [TokenExpiring]: Emitted when token is about to expire
/// - [TokenExpired]: Emitted when token has expired
/// - [TokenRefreshed]: Emitted when token is successfully refreshed
/// - [TokenRefreshFailed]: Emitted when token refresh fails
class RefreshTokenUseCase extends NoParamsUseCase {
  final UserRepository _repository;
  final _eventController = StreamController<DomainEvent>.broadcast();
  
  /// Timer for token expiration
  Timer? _expirationTimer;
  
  /// Timer for token expiration warning
  Timer? _warningTimer;
  
  /// Duration before expiry to emit warning
  static const warningThreshold = Duration(minutes: 5);
  
  /// Duration before expiry to attempt refresh
  static const refreshThreshold = Duration(minutes: 10);
  
  /// Whether a refresh operation is in progress
  bool _isRefreshing = false;

  RefreshTokenUseCase(this._repository) {
    // Listen to repository events and manage token lifecycle
    _repository.events.listen((event) {
      if (event is TokenObtained || event is TokenRefreshed) {
        _isRefreshing = false;
        _setupExpirationTimers(event.expiresAt);
        _eventController.add(event);
      } else if (event is OperationFailure) {
        _isRefreshing = false;
        _eventController.add(TokenRefreshFailed(event.error));
      } else if (event is TokenExpired || 
                event is TokenExpiring || 
                event is OperationInProgress) {
        _eventController.add(event);
      }
    });
  }

  /// Setup timers for token expiration and warning
  void _setupExpirationTimers(DateTime expiresAt) {
    // Cancel existing timers
    _expirationTimer?.cancel();
    _warningTimer?.cancel();

    final now = DateTime.now();
    final timeUntilExpiry = expiresAt.difference(now);

    // Don't set timers if token is already expired
    if (timeUntilExpiry.isNegative) {
      _eventController.add(TokenExpired());
      return;
    }

    // Set warning timer
    if (timeUntilExpiry > warningThreshold) {
      _warningTimer = Timer(
        timeUntilExpiry - warningThreshold,
        () {
          _eventController.add(TokenExpiring(warningThreshold));
          // Attempt refresh if not already in progress
          if (!_isRefreshing) {
            execute();
          }
        },
      );
    }

    // Set expiration timer
    _expirationTimer = Timer(
      timeUntilExpiry,
      () {
        _eventController.add(TokenExpired());
        // Clear timers as they're no longer needed
        _expirationTimer = null;
        _warningTimer = null;
      },
    );

    // If token is close to expiry, attempt refresh immediately
    if (timeUntilExpiry <= refreshThreshold && !_isRefreshing) {
      execute();
    }
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  void execute([void params]) {
    if (_isRefreshing) return; // Prevent concurrent refreshes
    
    _isRefreshing = true;
    _repository.refreshToken();
  }

  @override
  void dispose() {
    _expirationTimer?.cancel();
    _warningTimer?.cancel();
    _eventController.close();
  }
}

================
File: domain/usecases/user/register_usecase.dart
================
import 'dart:async';

import '../../core/events.dart';
import '../../core/user_events.dart';
import '../../repositories/user_repository.dart';
import '../base_usecase.dart';

/// Parameters for user registration
class RegisterParams {
  /// Username for registration
  /// Must be non-empty and contain only valid characters
  final String username;

  const RegisterParams({
    required this.username,
  });

  /// Validate registration parameters
  String? validate() {
    final trimmed = username.trim();
    if (trimmed.isEmpty) {
      return 'Username cannot be empty';
    }
    if (trimmed.length < 3) {
      return 'Username must be at least 3 characters';
    }
    if (!RegExp(r'^[a-zA-Z0-9_]+$').hasMatch(trimmed)) {
      return 'Username can only contain letters, numbers, and underscores';
    }
    return null;
  }
}

/// Use case for user registration
/// 
/// Flow:
/// 1. Validates the username
/// 2. Calls repository to register user
/// 3. Emits appropriate events:
///    - [OperationInProgress]: When registration starts
///    - [UserRegistered]: When registration succeeds
///    - [RegistrationFailed]: When validation or registration fails
class RegisterUseCase extends BaseUseCase<RegisterParams> {
  final UserRepository _repository;
  final _eventController = StreamController<DomainEvent>.broadcast();

  RegisterUseCase(this._repository) {
    // Listen to repository events and transform them if needed
    _repository.events.listen((event) {
      if (event is UserRegistered) {
        // Repository provides domain User object, forward as is
        _eventController.add(event);
      } else if (event is OperationFailure) {
        // Transform generic failure to registration-specific failure
        _eventController.add(RegistrationFailed(event.error));
      } else if (event is OperationInProgress) {
        _eventController.add(event);
      }
    });
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  void execute(RegisterParams params) {
    // Validate input parameters
    final validationError = params.validate();
    if (validationError != null) {
      _eventController.add(RegistrationFailed(validationError));
      return;
    }

    // Proceed with registration
    _repository.register(params.username.trim());
  }

  @override
  void dispose() {
    _eventController.close();
  }
}

================
File: domain/usecases/user/reset_password_usecase.dart
================
import 'dart:async';

import '../../core/events.dart';
import '../../repositories/user_repository.dart';
import '../base_usecase.dart';

/// Parameters for requesting password reset
class RequestPasswordResetParams {
  final String email;

  RequestPasswordResetParams({required this.email});
}

/// Parameters for completing password reset
class CompletePasswordResetParams {
  final String token;
  final String newPassword;

  CompletePasswordResetParams({
    required this.token,
    required this.newPassword,
  });
}

/// Use case for password reset flow
class ResetPasswordUseCase extends BaseUseCase<RequestPasswordResetParams> {
  final UserRepository _repository;
  final _eventController = StreamController<DomainEvent>.broadcast();

  ResetPasswordUseCase(this._repository) {
    _repository.events.listen((event) {
      if (event is PasswordResetRequested ||
          event is PasswordResetCompleted ||
          event is PasswordResetFailed ||
          event is OperationInProgress) {
        _eventController.add(event);
      }
    });
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  void execute(RequestPasswordResetParams params) {
    _repository.requestPasswordReset(params.email);
  }

  /// Complete the password reset process
  void completeReset(CompletePasswordResetParams params) {
    _repository.completePasswordReset(
      token: params.token,
      newPassword: params.newPassword,
    );
  }

  @override
  void dispose() {
    _eventController.close();
  }
}

================
File: domain/usecases/user/sign_out_usecase.dart
================
import 'dart:async';

import '../../core/events.dart';
import '../../repositories/user_repository.dart';
import '../base_usecase.dart';

/// Use case for signing out the current user
/// 
/// Responsibilities:
/// 1. Clear user tokens and credentials
/// 2. Clean up any user-specific data
/// 3. Notify system of user sign out
/// 
/// Events:
/// - [UserSignedOut]: When sign out is successful
/// - [OperationFailure]: When sign out fails
/// - [OperationInProgress]: When sign out is in progress
class SignOutUseCase extends NoParamsUseCase {
  final UserRepository _repository;
  final _eventController = StreamController<DomainEvent>.broadcast();
  
  /// Whether a sign out operation is in progress
  bool _isSigningOut = false;

  SignOutUseCase(this._repository) {
    // Listen to repository events and transform them if needed
    _repository.events.listen((event) {
      if (event is UserSignedOut) {
        _isSigningOut = false;
        _eventController.add(event);
      } else if (event is OperationFailure) {
        _isSigningOut = false;
        // Transform generic failure to sign-out specific failure if needed
        final error = event.error.toLowerCase();
        if (error.contains('already signed out') || 
            error.contains('no user') ||
            error.contains('unauthorized')) {
          // If user is already signed out or not found, consider it a success
          _eventController.add(UserSignedOut());
        } else {
          _eventController.add(event);
        }
      } else if (event is OperationInProgress) {
        _eventController.add(event);
      }
    });
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  void execute([void params]) {
    if (_isSigningOut) return; // Prevent concurrent sign outs
    
    _isSigningOut = true;
    _repository.signOut();
  }

  @override
  void dispose() {
    _eventController.close();
  }
}

================
File: domain/usecases/user/update_profile_usecase.dart
================
import 'dart:async';

import '../../core/events.dart';
import '../../entities/user.dart';
import '../../repositories/user_repository.dart';
import '../base_usecase.dart';

/// Parameters for updating user profile
class UpdateProfileParams {
  final User user;

  UpdateProfileParams({required this.user});
}

/// Use case for updating user profile
class UpdateProfileUseCase extends BaseUseCase<UpdateProfileParams> {
  final UserRepository _repository;
  final _eventController = StreamController<DomainEvent>.broadcast();

  UpdateProfileUseCase(this._repository) {
    _repository.events.listen((event) {
      if (event is UserProfileUpdated ||
          event is OperationInProgress ||
          event is OperationFailure) {
        _eventController.add(event);
      }
    });
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  void execute(UpdateProfileParams params) {
    _repository.updateProfile(params.user);
  }

  @override
  void dispose() {
    _eventController.close();
  }
}

================
File: domain/usecases/base_usecase.dart
================
import 'dart:async';
import '../core/events.dart';

/// Base interface for all use cases
/// [P] is the parameter type
abstract class BaseUseCase<P> {
  /// Stream of domain events from this use case
  Stream<DomainEvent> get events;

  /// Execute the use case with given parameters
  void execute(P params);

  /// Dispose of any resources
  void dispose();
}

/// Use case that doesn't require any parameters
abstract class NoParamsUseCase extends BaseUseCase<void> {
  @override
  void execute([void params]);
}

================
File: implementations/config/api_config.dart
================
/// Configuration for API endpoints and settings
class ApiConfig {
  /// Base URL for the API
  static const baseUrl = 'https://api.friday.com';

  /// API version prefix
  static const apiVersion = 'v1';

  /// Full API base URL with version
  static String get apiBaseUrl => '$baseUrl/$apiVersion';

  /// API endpoints
  static const endpoints = _Endpoints();

  /// Token configuration
  static const tokenConfig = _TokenConfig();

  /// HTTP headers
  static const headers = _Headers();

  /// API request/response keys
  static const keys = _ApiKeys();

  /// Operation names
  static const operations = _Operations();
}

/// API endpoint paths
class _Endpoints {
  const _Endpoints();

  /// Authentication endpoints
  final auth = const _AuthEndpoints();
}

/// Authentication related endpoints
class _AuthEndpoints {
  const _AuthEndpoints();

  /// Register new user endpoint
  String get register => '/auth/register';

  /// Obtain token endpoint
  String get token => '/auth/token';

  /// Get current user info endpoint
  String get me => '/auth/me';
}

/// Token related configuration
class _TokenConfig {
  const _TokenConfig();

  /// Duration before token expiry when we should refresh
  Duration get refreshThreshold => const Duration(minutes: 5);

  /// Estimated token lifetime
  Duration get tokenLifetime => const Duration(hours: 1);
}

/// Common HTTP headers
class _Headers {
  const _Headers();

  /// Content type for JSON requests
  Map<String, String> get json => {
        'Content-Type': 'application/json',
      };

  /// Headers for authenticated requests
  Map<String, String> withAuth(String token) => {
        ...json,
        'Authorization': 'Bearer $token',
      };
}

/// API request/response keys
class _ApiKeys {
  const _ApiKeys();

  /// Common response keys
  final common = const _CommonKeys();

  /// Authentication related keys
  final auth = const _AuthKeys();

  /// User related keys
  final user = const _UserKeys();
}

/// Common response keys
class _CommonKeys {
  const _CommonKeys();

  /// Response data wrapper key
  String get data => 'data';

  /// Error message key
  String get message => 'message';
}

/// Authentication related keys
class _AuthKeys {
  const _AuthKeys();

  /// User secret key in registration response
  String get userSecret => 'user_secret';

  /// Access token key in token response
  String get accessToken => 'access_token';

  /// Username key in requests
  String get username => 'username';
}

/// User related keys
class _UserKeys {
  const _UserKeys();

  /// User ID key
  String get id => 'id';

  /// User creation timestamp key
  String get createdAt => 'created_at';

  /// User last modified timestamp key
  String get updatedAt => 'updated_at';
}

/// Operation names for events and logging
class _Operations {
  const _Operations();

  /// Authentication related operations
  final auth = const _AuthOperations();
}

/// Authentication related operation names
class _AuthOperations {
  const _AuthOperations();

  /// Register operation name
  String get register => 'auth_register';

  /// Obtain token operation name
  String get obtainToken => 'auth_obtain_token';

  /// Get current user operation name
  String get getCurrentUser => 'auth_get_current_user';

  /// Sign out operation name
  String get signOut => 'auth_sign_out';

  /// Refresh token operation name
  String get refreshToken => 'auth_refresh_token';

  /// Generic auth operation name
  String get generic => 'auth_operation';
}

================
File: implementations/config/error_messages.dart
================
/// Configuration for error messages across the application
class ErrorMessages {
  /// Authentication related error messages
  static const auth = _AuthErrors();
  
  /// User related error messages
  static const user = _UserErrors();
  
  /// Operation related error messages
  static const operation = _OperationErrors();
}

/// Authentication related error messages
class _AuthErrors {
  const _AuthErrors();

  /// Token related errors
  String get noToken => 'No access token available';
  String get tokenExpired => 'Access token has expired';
  String get noUserSecret => 'No user secret available for token refresh';
  String get tokenRefreshFailed => 'Failed to refresh access token';
  String get invalidCredentials => 'Invalid credentials provided';

  /// Registration errors
  String get registrationFailed => 'Registration failed';
  String get usernameTaken => 'Username is already taken';
  String get invalidUsername => 'Invalid username format';

  /// General auth errors
  String get unauthorized => 'Unauthorized access';
  String get sessionExpired => 'Session has expired';
  String get authenticationFailed => 'Authentication failed';
}

/// User related error messages
class _UserErrors {
  const _UserErrors();

  /// User operation errors
  String get userNotFound => 'User not found';
  String get invalidUserData => 'Invalid user data provided';
  String get userUpdateFailed => 'Failed to update user information';
  
  /// Operation support errors
  String get createNotSupported => 'Create operation not supported for User entity';
  String get updateNotSupported => 'Update operation not supported for User entity';
  String get deleteNotSupported => 'Delete operation not supported for User entity';
  String get listNotSupported => 'List operation not supported for User entity';
  String get readNotSupported => 'Read operation not supported for User entity';
}

/// General operation error messages
class _OperationErrors {
  const _OperationErrors();

  /// Data errors
  String get unexpectedDataType => 'Unexpected data type from data source';
  String get invalidResponse => 'Invalid response format';
  String get dataNotFound => 'Requested data not found';

  /// Network errors
  String get networkError => 'Network connection error';
  String get serverError => 'Server error occurred';
  String get timeoutError => 'Operation timed out';

  /// State errors
  String get invalidState => 'Invalid operation state';
  String get operationInProgress => 'Operation already in progress';
  String get operationFailed => 'Operation failed';
}

================
File: implementations/datasources/user_ds_impl.dart
================
import 'dart:async';
import 'dart:convert';

import 'package:http/http.dart' as http;
import 'package:isar/isar.dart';
import 'package:synchronized/synchronized.dart';
import 'package:meta/meta.dart';

import '../../domain/core/events.dart';
import '../../domain/core/retry_config.dart';
import '../../domain/core/retry_events.dart';
import '../../domain/core/service_events.dart';
import '../../domain/core/user_events.dart';
import '../../domain/datasources/user_ds.dart';
import '../../domain/entities/user.dart';
import '../config/api_config.dart';
import '../config/error_messages.dart';
import '../models/auth_credentials.dart';
import '../models/user_model.dart';
import '../../domain/core/circuit_breaker.dart';

/// Implementation of UserDataSource using HTTP and Isar
class UserDataSourceImpl implements UserDataSource {
  final Isar _isar;
  final http.Client _client;
  final StreamController<DomainEvent> _eventController;
  final Lock _refreshLock;
  final RetryConfig _retryConfig;
  final CircuitBreaker _circuitBreaker;
  String? _currentToken;

  UserDataSourceImpl({
    required Isar isar,
    required http.Client client,
    required RetryConfig retryConfig,
    required CircuitBreakerConfig circuitBreakerConfig,
  }) : _isar = isar,
       _client = client,
       _retryConfig = retryConfig,
       _eventController = StreamController<DomainEvent>.broadcast(),
       _refreshLock = Lock(),
       _circuitBreaker = CircuitBreaker(circuitBreakerConfig) {
    _initialize();
  }

  // Public interface
  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  bool get isRefreshing => _refreshLock.locked;

  @override
  Future<String?> get cachedUserSecret async {
    final credentials = await _isar.collection<AuthCredentials>().get(1);
    return credentials?.userSecret;
  }

  @override
  Future<String?> get cachedAccessToken async {
    final credentials = await _isar.collection<AuthCredentials>().get(1);
    return credentials?.accessToken;
  }

  @override
  Future<DateTime?> get tokenExpiresAt async {
    final credentials = await _isar.collection<AuthCredentials>().get(1);
    return credentials?.tokenExpiresAt;
  }

  /// Get the circuit breaker instance (for testing only)
  @visibleForTesting
  CircuitBreaker get circuitBreaker => _circuitBreaker;

  void _initialize() {
    // Forward circuit breaker events to domain events
    _circuitBreaker.events.listen((event) {
      switch (event.type) {
        case 'transition_to_open':
          _eventController.add(ServiceDegraded(event.timestamp));
          break;
        case 'transition_to_half_open':
          // No event needed for half-open state
          break;
        case 'transition_to_closed':
          _eventController.add(ServiceRestored(event.timestamp));
          break;
        case 'operation_rejected':
          _eventController.add(OperationRejected('Service unavailable'));
          break;
      }
    });
  }

  @override
  Stream<User> create(User entity) => 
    throw UnsupportedError(ErrorMessages.user.createNotSupported);

  @override
  Stream<void> delete(String id) =>
    throw UnsupportedError(ErrorMessages.user.deleteNotSupported);

  @override
  Stream<List<User>> list({Map<String, dynamic>? filters}) =>
    throw UnsupportedError(ErrorMessages.user.listNotSupported);

  @override
  Stream<User> read(String id) =>
    throw UnsupportedError(ErrorMessages.user.readNotSupported);

  @override
  Stream<User> update(User entity) =>
    throw UnsupportedError(ErrorMessages.user.updateNotSupported);

  @override
  bool isOperationSupported(String operation) {
    switch (operation) {
      case 'register':
      case 'getCurrentUser':
      case 'obtainToken':
      case 'signOut':
        return true;
      default:
        return false;
    }
  }

  @override
  Future<void> initialize() async {
    final credentials = await _isar.collection<AuthCredentials>().get(1);
    if (credentials != null) {
      _currentToken = credentials.accessToken;
      // If token is expired or about to expire, refresh it
      if (credentials.tokenExpiresAt != null && 
          credentials.tokenExpiresAt!.isBefore(DateTime.now().add(ApiConfig.tokenConfig.refreshThreshold))) {
        if (credentials.userSecret != null) {
          await obtainToken(credentials.userSecret!).first;
        }
      }
    }
  }

  /// Execute an operation with retry logic and event tracking
  Future<T> _executeWithRetry<T>(
    String operation,
    Future<T> Function() apiCall,
  ) async {
    var attempts = 0;
    var delay = _retryConfig.initialDelay;

    while (true) {
      attempts++;
      
      try {
        final result = await _circuitBreaker.execute(apiCall);
        
        // On success, emit appropriate events
        if (attempts > 1) {
          _eventController.add(RetrySuccess(operation, attempts));
        }
        
        return result;
      } catch (e) {
        // Check if we've exhausted retries
        if (attempts >= _retryConfig.maxAttempts) {
          _eventController.add(RetryExhausted(operation, e, attempts));
          rethrow;
        }

        // Emit retry attempt event and wait before next try
        _eventController.add(RetryAttempt(operation, attempts, delay, e.toString()));
        await Future.delayed(delay);
        
        // Calculate next delay with exponential backoff
        delay = Duration(milliseconds: 
          (delay.inMilliseconds * _retryConfig.backoffFactor)
            .round()
            .clamp(0, _retryConfig.maxDelay.inMilliseconds)
        );
      }
    }
  }

  @override
  Stream<User> register(String username) async* {
    try {
      _eventController.add(OperationInProgress(ApiConfig.operations.auth.register));
      
      final response = await _executeWithRetry<http.Response>(
        ApiConfig.operations.auth.register, 
        () async {
          final response = await _client.post(
            Uri.parse('${ApiConfig.baseUrl}${ApiConfig.endpoints.auth.register}'),
            headers: ApiConfig.headers.json,
            body: jsonEncode({
              ApiConfig.keys.auth.username: username,
            }),
          );

          if (response.statusCode == 201) {
            return response;
          }

          final error = await _handleErrorResponse(
            ApiConfig.operations.auth.register,
            response,
            ErrorMessages.auth.registrationFailed
          );
          throw error;
        }
      );

      final data = jsonDecode(response.body)[ApiConfig.keys.common.data];
      final userModel = UserModel.fromJson(data);
      final user = userModel.toDomain();
      
      await _isar.writeTxn(() async {
        await _isar.collection<AuthCredentials>().put(
          AuthCredentials()
            ..id = 1
            ..userSecret = userModel.userSecret // store as provided
        );
      });

      _eventController.add(OperationSuccess(ApiConfig.operations.auth.register, user));
      yield user;
    } catch (e) {
      final error = await _handleError(ApiConfig.operations.auth.register, e);
      throw error;
    }
  }

  @override
  Stream<String> obtainToken(String userSecret) async* {
    _eventController.add(OperationInProgress(ApiConfig.operations.auth.obtainToken));

    try {
      final response = await _executeWithRetry<http.Response>(
        ApiConfig.operations.auth.obtainToken,
        () async {
          final response = await _client.post(
            Uri.parse('${ApiConfig.baseUrl}${ApiConfig.endpoints.auth.token}'),
            body: jsonEncode({ApiConfig.keys.auth.userSecret: userSecret}),
            headers: ApiConfig.headers.json,
          );

          if (response.statusCode == 200) {
            return response;
          }

          final error = await _handleErrorResponse(
            ApiConfig.operations.auth.obtainToken,
            response,
            ErrorMessages.auth.authenticationFailed
          );
          throw error;
        },
      );

      final data = jsonDecode(response.body)[ApiConfig.keys.common.data];
      final token = data[ApiConfig.keys.auth.accessToken] as String;
      _currentToken = token;
      final expiresAt = DateTime.now().add(ApiConfig.tokenConfig.tokenLifetime);
      
      await _isar.writeTxn(() async {
        final current = await _isar.collection<AuthCredentials>().get(1);
        await _isar.collection<AuthCredentials>().put(
          (current ?? AuthCredentials())
            ..id = 1
            ..userSecret = userSecret
            ..accessToken = token
            ..tokenExpiresAt = expiresAt,
        );
      });
      
      _eventController.add(TokenObtained(token, expiresAt));
      yield token;
    } catch (e) {
      final error = await _handleError(ApiConfig.operations.auth.obtainToken, e);
      throw error;
    }
  }

  @override
  Stream<User> getCurrentUser() async* {
    _eventController.add(OperationInProgress(ApiConfig.operations.auth.getCurrentUser));
    
    try {
      final response = await _executeWithRetry(
        ApiConfig.operations.auth.getCurrentUser,
        () async {
          if (_currentToken == null) {
            throw Exception(ErrorMessages.auth.noToken);
          }
          
          final response = await _client.get(
            Uri.parse('${ApiConfig.baseUrl}${ApiConfig.endpoints.auth.me}'),
            headers: ApiConfig.headers.withAuth(_currentToken!),
          );

          if (response.statusCode == 200) {
            return response;
          }
          
          final error = await _handleErrorResponse(
            ApiConfig.operations.auth.getCurrentUser,
            response,
            ErrorMessages.user.userNotFound
          );
          throw error;
        },
      );

      final data = jsonDecode(response.body)[ApiConfig.keys.common.data];
      final userModel = UserModel.fromJson(data);
      final user = userModel.toDomain();
      
      _eventController.add(OperationSuccess(ApiConfig.operations.auth.getCurrentUser, user));
      yield user;
    } catch (e) {
      final error = await _handleError(ApiConfig.operations.auth.getCurrentUser, e);
      throw error;
    }
  }

  @override
  Stream<void> signOut() async* {
    _eventController.add(OperationInProgress(ApiConfig.operations.auth.signOut));
    
    try {
      await _executeWithRetry(
        ApiConfig.operations.auth.signOut,
        () async {
          await _isar.writeTxn(() async {
            await _isar.collection<AuthCredentials>().clear();
          });
          _currentToken = null;
          return null;
        },
      );
      
      _eventController.add(OperationSuccess(ApiConfig.operations.auth.signOut, null));
      _eventController.add(UserLoggedOut());
      yield null;
    } catch (e) {
      final error = await _handleError(ApiConfig.operations.auth.signOut, e);
      throw error;
    }
  }

  @override
  Future<T> executeWithRefresh<T>(
    Future<T> Function() apiCall,
    Future<void> Function()? onRefreshSuccess,
  ) async {
    try {
      return await apiCall();
    } catch (e) {
      final statusCode = e is http.Response ? (e).statusCode : 
                        (e is http.ClientException ? 0 : -1);
                        
      if (statusCode == 401 || statusCode == 403) {
        // Use lock to prevent multiple simultaneous token refreshes
        return await _refreshLock.synchronized(() async {
          try {
            // Double-check if token is still invalid after acquiring lock
            try {
              return await apiCall();
            } catch (_) {
              // Original error still occurs, proceed with refresh
            }
            
            final credentials = await _isar.collection<AuthCredentials>().get(1);
            if (credentials?.userSecret == null) {
              throw Exception(ErrorMessages.auth.noUserSecret);
            }
            
            // Refresh token
            await obtainToken(credentials!.userSecret!).first;
            if (onRefreshSuccess != null) {
              await onRefreshSuccess();
            }
            
            // Retry the original call
            return await apiCall();
          } catch (refreshError) {
            // If refresh fails, ensure we emit appropriate events
            _eventController.add(OperationFailure(
              ApiConfig.operations.auth.refreshToken,
              refreshError.toString()
            ));
            rethrow;
          }
        });
      }
      rethrow;
    }
  }

  /// Handle HTTP error responses
  /// Returns a ClientException with appropriate error message
  Future<http.ClientException> _handleErrorResponse(String operation, http.Response response, String defaultMessage) async {
    String message;
    try {
      final body = jsonDecode(response.body);
      message = (body[ApiConfig.keys.common.message] as String?) ?? defaultMessage;
    } catch (e) {
      // Handle invalid JSON response
      message = response.statusCode >= 500 ? 
        ErrorMessages.operation.serverError : 
        ErrorMessages.operation.invalidResponse;
    }
    _eventController.add(OperationFailure(operation, message));
    await Future.delayed(Duration.zero); // Ensure events are processed
    return http.ClientException(message);
  }

  /// Handle general errors
  /// Returns the original error or wraps it in an appropriate exception type
  Future<Object> _handleError(String operation, Object error) async {
    if (error is CircuitBreakerException) {
      _eventController.add(OperationFailure(operation, error.message));
      await Future.delayed(Duration.zero);
      return error;
    } else if (error is http.ClientException) {
      _eventController.add(OperationFailure(operation, error.message));
      await Future.delayed(Duration.zero);
      return error;
    } else if (error is TimeoutException) {
      final message = ErrorMessages.operation.timeoutError;
      _eventController.add(OperationFailure(operation, message));
      await Future.delayed(Duration.zero);
      return TimeoutException(message);
    } else if (error is FormatException) {
      final message = ErrorMessages.operation.invalidResponse;
      _eventController.add(OperationFailure(operation, message));
      await Future.delayed(Duration.zero);
      return FormatException(message);
    } else {
      final message = error.toString();
      _eventController.add(OperationFailure(operation, message));
      await Future.delayed(Duration.zero);
      return error;
    }
  }

  @override
  void dispose() {
    _eventController.close();
    _circuitBreaker.dispose();
    _client.close();
  }
}

================
File: implementations/models/auth_credentials.dart
================
import 'package:isar/isar.dart';

part 'auth_credentials.g.dart';

/// Model for storing authentication credentials
@Collection()
class AuthCredentials {
  /// Primary key for Isar
  Id id = 1; // Fixed ID since we only store one instance

  /// User secret for obtaining tokens
  String? userSecret;

  /// Current access token
  String? accessToken;

  /// When the current token expires
  DateTime? tokenExpiresAt;

  /// Create a copy with updated token information
  AuthCredentials copyWithToken({
    required String accessToken,
    required DateTime expiresAt,
  }) {
    final copy = AuthCredentials()
      ..id = id
      ..userSecret = userSecret
      ..accessToken = accessToken
      ..tokenExpiresAt = expiresAt;
    return copy;
  }

  /// Create a copy with updated user secret
  AuthCredentials copyWithSecret({
    required String userSecret,
  }) {
    final copy = AuthCredentials()
      ..id = id
      ..userSecret = userSecret
      ..accessToken = accessToken
      ..tokenExpiresAt = tokenExpiresAt;
    return copy;
  }

  /// Check if token is expired or will expire soon
  bool isExpiredOrExpiring(Duration threshold) {
    if (tokenExpiresAt == null) return true;
    final now = DateTime.now();
    return now.isAfter(tokenExpiresAt!) ||
           now.add(threshold).isAfter(tokenExpiresAt!);
  }
}

================
File: implementations/models/auth_credentials.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_credentials.dart';

// **************************************************************************
// IsarCollectionGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: duplicate_ignore, non_constant_identifier_names, constant_identifier_names, invalid_use_of_protected_member, unnecessary_cast, prefer_const_constructors, lines_longer_than_80_chars, require_trailing_commas, inference_failure_on_function_invocation, unnecessary_parenthesis, unnecessary_raw_strings, unnecessary_null_checks, join_return_with_assignment, prefer_final_locals, avoid_js_rounded_ints, avoid_positional_boolean_parameters, always_specify_types

extension GetAuthCredentialsCollection on Isar {
  IsarCollection<AuthCredentials> get authCredentials => this.collection();
}

const AuthCredentialsSchema = CollectionSchema(
  name: r'AuthCredentials',
  id: 5186440161042841949,
  properties: {
    r'accessToken': PropertySchema(
      id: 0,
      name: r'accessToken',
      type: IsarType.string,
    ),
    r'tokenExpiresAt': PropertySchema(
      id: 1,
      name: r'tokenExpiresAt',
      type: IsarType.dateTime,
    ),
    r'userSecret': PropertySchema(
      id: 2,
      name: r'userSecret',
      type: IsarType.string,
    )
  },
  estimateSize: _authCredentialsEstimateSize,
  serialize: _authCredentialsSerialize,
  deserialize: _authCredentialsDeserialize,
  deserializeProp: _authCredentialsDeserializeProp,
  idName: r'id',
  indexes: {},
  links: {},
  embeddedSchemas: {},
  getId: _authCredentialsGetId,
  getLinks: _authCredentialsGetLinks,
  attach: _authCredentialsAttach,
  version: '3.1.0+1',
);

int _authCredentialsEstimateSize(
  AuthCredentials object,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  var bytesCount = offsets.last;
  {
    final value = object.accessToken;
    if (value != null) {
      bytesCount += 3 + value.length * 3;
    }
  }
  {
    final value = object.userSecret;
    if (value != null) {
      bytesCount += 3 + value.length * 3;
    }
  }
  return bytesCount;
}

void _authCredentialsSerialize(
  AuthCredentials object,
  IsarWriter writer,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  writer.writeString(offsets[0], object.accessToken);
  writer.writeDateTime(offsets[1], object.tokenExpiresAt);
  writer.writeString(offsets[2], object.userSecret);
}

AuthCredentials _authCredentialsDeserialize(
  Id id,
  IsarReader reader,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  final object = AuthCredentials();
  object.accessToken = reader.readStringOrNull(offsets[0]);
  object.id = id;
  object.tokenExpiresAt = reader.readDateTimeOrNull(offsets[1]);
  object.userSecret = reader.readStringOrNull(offsets[2]);
  return object;
}

P _authCredentialsDeserializeProp<P>(
  IsarReader reader,
  int propertyId,
  int offset,
  Map<Type, List<int>> allOffsets,
) {
  switch (propertyId) {
    case 0:
      return (reader.readStringOrNull(offset)) as P;
    case 1:
      return (reader.readDateTimeOrNull(offset)) as P;
    case 2:
      return (reader.readStringOrNull(offset)) as P;
    default:
      throw IsarError('Unknown property with id $propertyId');
  }
}

Id _authCredentialsGetId(AuthCredentials object) {
  return object.id;
}

List<IsarLinkBase<dynamic>> _authCredentialsGetLinks(AuthCredentials object) {
  return [];
}

void _authCredentialsAttach(
    IsarCollection<dynamic> col, Id id, AuthCredentials object) {
  object.id = id;
}

extension AuthCredentialsQueryWhereSort
    on QueryBuilder<AuthCredentials, AuthCredentials, QWhere> {
  QueryBuilder<AuthCredentials, AuthCredentials, QAfterWhere> anyId() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(const IdWhereClause.any());
    });
  }
}

extension AuthCredentialsQueryWhere
    on QueryBuilder<AuthCredentials, AuthCredentials, QWhereClause> {
  QueryBuilder<AuthCredentials, AuthCredentials, QAfterWhereClause> idEqualTo(
      Id id) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: id,
        upper: id,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterWhereClause>
      idNotEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            )
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            );
      } else {
        return query
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            )
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            );
      }
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterWhereClause>
      idGreaterThan(Id id, {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.greaterThan(lower: id, includeLower: include),
      );
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterWhereClause> idLessThan(
      Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.lessThan(upper: id, includeUpper: include),
      );
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterWhereClause> idBetween(
    Id lowerId,
    Id upperId, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: lowerId,
        includeLower: includeLower,
        upper: upperId,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension AuthCredentialsQueryFilter
    on QueryBuilder<AuthCredentials, AuthCredentials, QFilterCondition> {
  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenIsNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNull(
        property: r'accessToken',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenIsNotNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNotNull(
        property: r'accessToken',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenEqualTo(
    String? value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accessToken',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenGreaterThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'accessToken',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenLessThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'accessToken',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenBetween(
    String? lower,
    String? upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'accessToken',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'accessToken',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'accessToken',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'accessToken',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'accessToken',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accessToken',
        value: '',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      accessTokenIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'accessToken',
        value: '',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      idEqualTo(Id value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      idGreaterThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      idLessThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      idBetween(
    Id lower,
    Id upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'id',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      tokenExpiresAtIsNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNull(
        property: r'tokenExpiresAt',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      tokenExpiresAtIsNotNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNotNull(
        property: r'tokenExpiresAt',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      tokenExpiresAtEqualTo(DateTime? value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'tokenExpiresAt',
        value: value,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      tokenExpiresAtGreaterThan(
    DateTime? value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'tokenExpiresAt',
        value: value,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      tokenExpiresAtLessThan(
    DateTime? value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'tokenExpiresAt',
        value: value,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      tokenExpiresAtBetween(
    DateTime? lower,
    DateTime? upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'tokenExpiresAt',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretIsNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNull(
        property: r'userSecret',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretIsNotNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNotNull(
        property: r'userSecret',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretEqualTo(
    String? value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'userSecret',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretGreaterThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'userSecret',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretLessThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'userSecret',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretBetween(
    String? lower,
    String? upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'userSecret',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'userSecret',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'userSecret',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'userSecret',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'userSecret',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'userSecret',
        value: '',
      ));
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterFilterCondition>
      userSecretIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'userSecret',
        value: '',
      ));
    });
  }
}

extension AuthCredentialsQueryObject
    on QueryBuilder<AuthCredentials, AuthCredentials, QFilterCondition> {}

extension AuthCredentialsQueryLinks
    on QueryBuilder<AuthCredentials, AuthCredentials, QFilterCondition> {}

extension AuthCredentialsQuerySortBy
    on QueryBuilder<AuthCredentials, AuthCredentials, QSortBy> {
  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      sortByAccessToken() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accessToken', Sort.asc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      sortByAccessTokenDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accessToken', Sort.desc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      sortByTokenExpiresAt() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'tokenExpiresAt', Sort.asc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      sortByTokenExpiresAtDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'tokenExpiresAt', Sort.desc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      sortByUserSecret() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'userSecret', Sort.asc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      sortByUserSecretDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'userSecret', Sort.desc);
    });
  }
}

extension AuthCredentialsQuerySortThenBy
    on QueryBuilder<AuthCredentials, AuthCredentials, QSortThenBy> {
  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      thenByAccessToken() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accessToken', Sort.asc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      thenByAccessTokenDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accessToken', Sort.desc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy> thenById() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.asc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy> thenByIdDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.desc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      thenByTokenExpiresAt() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'tokenExpiresAt', Sort.asc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      thenByTokenExpiresAtDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'tokenExpiresAt', Sort.desc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      thenByUserSecret() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'userSecret', Sort.asc);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QAfterSortBy>
      thenByUserSecretDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'userSecret', Sort.desc);
    });
  }
}

extension AuthCredentialsQueryWhereDistinct
    on QueryBuilder<AuthCredentials, AuthCredentials, QDistinct> {
  QueryBuilder<AuthCredentials, AuthCredentials, QDistinct>
      distinctByAccessToken({bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'accessToken', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QDistinct>
      distinctByTokenExpiresAt() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'tokenExpiresAt');
    });
  }

  QueryBuilder<AuthCredentials, AuthCredentials, QDistinct>
      distinctByUserSecret({bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'userSecret', caseSensitive: caseSensitive);
    });
  }
}

extension AuthCredentialsQueryProperty
    on QueryBuilder<AuthCredentials, AuthCredentials, QQueryProperty> {
  QueryBuilder<AuthCredentials, int, QQueryOperations> idProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'id');
    });
  }

  QueryBuilder<AuthCredentials, String?, QQueryOperations>
      accessTokenProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'accessToken');
    });
  }

  QueryBuilder<AuthCredentials, DateTime?, QQueryOperations>
      tokenExpiresAtProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'tokenExpiresAt');
    });
  }

  QueryBuilder<AuthCredentials, String?, QQueryOperations>
      userSecretProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'userSecret');
    });
  }
}

================
File: implementations/models/user_model.dart
================
import '../../domain/entities/user.dart';
import '../config/api_config.dart';

/// Model class for User data from API
class UserModel {
  final String id;
  final String username;
  final String? userSecret;
  final String? accessToken;
  final DateTime createdAt;
  final DateTime? updatedAt;

  const UserModel({
    required this.id,
    required this.username,
    this.userSecret,
    this.accessToken,
    required this.createdAt,
    this.updatedAt,
  });

  /// Create model from API JSON
  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json[ApiConfig.keys.user.id] as String,
      username: json[ApiConfig.keys.auth.username] as String,
      userSecret: json[ApiConfig.keys.auth.userSecret] as String?,
      accessToken: json[ApiConfig.keys.auth.accessToken] as String?,
      createdAt: DateTime.parse(json[ApiConfig.keys.user.createdAt] as String),
      updatedAt: json[ApiConfig.keys.user.updatedAt] != null
          ? DateTime.parse(json[ApiConfig.keys.user.updatedAt] as String)
          : null,
    );
  }

  /// Convert model to JSON for API
  Map<String, dynamic> toJson() {
    return {
      ApiConfig.keys.user.id: id,
      ApiConfig.keys.auth.username: username,
      ApiConfig.keys.auth.userSecret: userSecret,
      ApiConfig.keys.auth.accessToken: accessToken,
      ApiConfig.keys.user.createdAt: createdAt.toIso8601String(),
      ApiConfig.keys.user.updatedAt: updatedAt?.toIso8601String(),
    };
  }

  /// Convert to domain entity
  User toDomain() {
    return User(
      id: id,
      username: username,
      userSecret: userSecret,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }
}

================
File: implementations/repositories/user_repository_impl.dart
================
import 'dart:async';

import '../../domain/core/events.dart';
import '../../domain/core/user_events.dart';
import '../../domain/datasources/user_ds.dart';
import '../../domain/entities/user.dart';
import '../../domain/repositories/user_repository.dart';
import '../config/api_config.dart';

/// Implementation of UserRepository that provides reactive streams
class UserRepositoryImpl implements UserRepository {
  final UserDataSource _dataSource;
  final _eventController = StreamController<DomainEvent>.broadcast();
  
  String? _currentToken;
  String? _userSecret;
  DateTime? _tokenExpiresAt;
  User? _currentUser;

  UserRepositoryImpl(this._dataSource) {
    // Initialize state from data source
    _dataSource.cachedUserSecret.then((secret) => _userSecret = secret);
    
    // Listen to data source events and transform to domain events
    _dataSource.events.listen((event) {
      if (event is OperationSuccess) {
        if (event.data is User) {
          _handleUserSuccess(event.data as User);
        } else {
          _handleOperationFailure('Unexpected data type from data source');
        }
      } else if (event is OperationFailure) {
        _handleOperationFailure(event.error);
      } else {
        // Forward all other events
        _eventController.add(event);
      }
    });
  }

  void _handleUserSuccess(User user) {
    // Store user info
    _currentUser = user;
    
    // Check which operation completed based on the data
    if (user.userSecret != null) {
      // Registration success
      _userSecret = user.userSecret;
      _eventController.add(UserRegistered(user, user.userSecret!));
    } else {
      // User info success
      _eventController.add(CurrentUserRetrieved(user));
    }
  }

  void _handleOperationFailure(String error) {
    if (_currentToken == null) {
      _eventController.add(TokenAcquisitionFailed(error));
    } else {
      _eventController.add(OperationFailure(ApiConfig.operations.auth.generic, error));
    }
  }

  @override
  Stream<DomainEvent> get events => _eventController.stream;

  @override
  Stream<User> register(String username) async* {
    try {
      await for (final user in _dataSource.register(username)) {
        _currentUser = user;
        yield user;
      }
    } catch (e) {
      _handleOperationFailure(e.toString());
      rethrow;
    }
  }

  @override
  Stream<String> obtainToken(String userSecret) async* {
    _userSecret = userSecret;
    try {
      await for (final token in _dataSource.obtainToken(userSecret)) {
        _currentToken = token;
        _tokenExpiresAt = DateTime.now().add(ApiConfig.tokenConfig.tokenLifetime);
        yield token;
      }
    } catch (e) {
      _handleOperationFailure(e.toString());
      rethrow;
    }
  }

  @override
  Stream<String> refreshToken() async* {
    if (_userSecret == null) {
      throw Exception('No user secret available for token refresh');
    }
    
    try {
      yield* obtainToken(_userSecret!);
    } catch (e) {
      _eventController.add(TokenRefreshFailed(e.toString()));
      rethrow;
    }
  }

  @override
  Stream<User> getCurrentUser() async* {
    if (_currentToken == null) {
      throw Exception('No access token available');
    }
    
    _eventController.add(OperationInProgress(ApiConfig.operations.auth.getCurrentUser));
    
    try {
      await for (final user in _dataSource.getCurrentUser()) {
        _currentUser = user;
        yield user;
      }
    } catch (e) {
      _handleOperationFailure(e.toString());
      rethrow;
    }
  }

  @override
  Stream<void> signOut() async* {
    _eventController.add(OperationInProgress(ApiConfig.operations.auth.signOut));
    
    try {
      await _dataSource.signOut().drain<void>();
      _currentToken = null;
      _tokenExpiresAt = null;
      _currentUser = null;
      _eventController.add(UserLoggedOut());
      yield null;
    } catch (e) {
      _handleOperationFailure(e.toString());
      rethrow;
    }
  }

  @override
  bool get isAuthenticated => 
    _currentToken != null && 
    _tokenExpiresAt != null && 
    _tokenExpiresAt!.isAfter(DateTime.now());

  @override
  String? get currentToken => _currentToken;

  @override
  String? get currentUserSecret => _userSecret;

  @override
  DateTime? get tokenExpiresAt => _tokenExpiresAt;

  @override
  Stream<User> create(User entity) {
    throw UnimplementedError('Create operation not supported for User entity');
  }

  @override
  Stream<void> delete(String id) {
    throw UnimplementedError('Delete operation not supported for User entity');
  }

  @override
  Stream<List<User>> list({Map<String, dynamic>? filters}) {
    throw UnimplementedError('List operation not supported for User entity');
  }

  @override
  Stream<User> read(String id) {
    throw UnimplementedError('Read operation not supported for User entity');
  }

  @override
  Stream<User> update(User entity) {
    throw UnimplementedError('Update operation not supported for User entity');
  }

  @override
  void dispose() {
    _eventController.close();
  }
}



================================================================
End of Codebase
================================================================
